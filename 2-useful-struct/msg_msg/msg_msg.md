## msg_msg

### System V æ¶ˆæ¯é˜Ÿåˆ—

msg_queue ç»“æ„ä½“

```c
struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;		/* last msgsnd time */
	time64_t q_rtime;		/* last msgrcv time */
	time64_t q_ctime;		/* last change time */
	unsigned long q_cbytes;		/* current number of bytes on queue */
	unsigned long q_qnum;		/* number of messages in queue */
	unsigned long q_qbytes;		/* max number of bytes on queue */
	struct pid *q_lspid;		/* pid of last msgsnd */
	struct pid *q_lrpid;		/* last receive pid */

	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
} __randomize_layout;
```

å½“å¾€ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—å‘é€æ¶ˆæ¯æ—¶ï¼Œä¼šå½¢æˆå¦‚ä¸‹çš„ç»“æ„

![msg_queue](./imgs/msg_queue.png)

#### æ¶ˆæ¯

msg_msg ç»“æ„ä½“

```c
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;		/* message text size */
	struct msg_msgseg *next;
	void *security;
};
```

å½“**ä¸€æ¡æ¶ˆæ¯**é•¿åº¦è¶…è¿‡ä¸€é¡µæ—¶ï¼Œä¼šä½¿ç”¨ msg_msgseg æŒ‡å‘å‰©ä½™çš„æ¶ˆæ¯

```c
struct msg_msgseg {
	struct msg_msgseg *next;
};
```

![msg_msg](./imgs/msg_msg.png)


#### ç”¨æˆ·æ€ API

åœ¨ç”¨æˆ·æ€å¯ä»¥ä½¿ç”¨è¿™äº›å‡½æ•°æ“ä½œ msg_msg 
- ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ syscall ğŸ˜¤

```cpp
#include <sys/msg.h>

// æ¶ˆæ¯å®ä½“
struct mymsg {
	long    mtype;     /* Message type. */
	char    mtext[MSG_SZ];  /* Message text. */
}

// åˆ›å»ºå’Œè·å–ipcå†…æ ¸å¯¹è±¡ï¼Œè¿”å›å€¼å°±æ˜¯ msqid
int msgget(key_t key, int flags);
 
// msgsnd å’Œ msgrcv å‡½æ•° sz = MSG_SZ å¹¶ä¸” msgp ä¸º &struct mymsg

// å°†æ¶ˆæ¯å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
 
// ä»æ¶ˆæ¯é˜Ÿåˆ—è·å–æ¶ˆæ¯
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
 
// æŸ¥çœ‹ã€è®¾ç½®ã€åˆ é™¤ipcå†…æ ¸å¯¹è±¡(ç”¨æ³•å’Œshmctlä¸€æ ·)
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

å†…æ ¸å‡½æ•°è°ƒç”¨å…³ç³» ç±»ä¼¼å¦‚ä¸‹

```cpp
long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,
		 int msgflg)
{
	long mtype;

	if (get_user(mtype, &msgp->mtype))
		return -EFAULT;
	return do_msgsnd(msqid, mtype, msgp->mtext, msgsz, msgflg);
}

SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,
		int, msgflg)
{
	return ksys_msgsnd(msqid, msgp, msgsz, msgflg);
}
```

## åˆ©ç”¨æ€è·¯

1. ä¿®æ”¹ m_ts: msg text sizeï¼Œæˆ‘ä»¬æ”¹å¤§ï¼Œå°±å¯ä»¥è¯»å– next æŒ‡é’ˆçš„ç»“æ„ä½“å†…å®¹ã€‚å‡ ä¹æ˜¯ä»»æ„åœ°å€è¯»å–ï¼ˆåˆ›å»ºä¸€ä¸ªæ¶ˆæ¯å¤§å° = 0x1000-0x30+æˆ‘ä»¬æƒ³è¦çš„sizeï¼Œä½¿ç”¨åˆ° msg_msgsegã€‚åªè¦æˆ‘ä»¬æ”¹å˜ m_tsï¼Œå°±å¯ä»¥è¶Šç•Œè¯»ï¼‰
2. ä¿®æ”¹ m_list.next: å‚è€ƒ CVE-2021-22555 ä¸»ä»æ¶ˆæ¯ ä¸¤ä¸ªä¸»æ¶ˆæ¯æŒ‡å‘åŒä¸€ä¸ªä»æ¶ˆæ¯ï¼Œä»è€Œé€ æˆç±»ä¼¼ UAF é—®é¢˜
3. msg_msgseg->nextï¼Œä»»æ„åœ°å€å†™ï¼Œå¯èƒ½éœ€è¦å€ŸåŠ©æ¡ä»¶ç«äº‰ã€‚

msgsnd: åœ¨å†…æ ¸ä¸­è°ƒç”¨ do_msgsnd ç„¶åè°ƒç”¨ load_msg
- alloc ä¸€ä¸ª message, é•¿åº¦å¤§äº PAGE_SIZE ä¼šåˆ›å»ºä¸€ä¸ª msg_msgseg
- æˆ‘ä»¬ä¿®æ”¹ next æŒ‡é’ˆï¼Œé€ æˆä»»æ„åœ°å€å†™

```c
struct msg_msg *load_msg(const void __user *src, size_t len)
{
	struct msg_msg *msg;
	struct msg_msgseg *seg;
	int err = -EFAULT;
	size_t alen;

	msg = alloc_msg(len);
	if (msg == NULL)
		return ERR_PTR(-ENOMEM);

	alen = min(len, DATALEN_MSG);
	if (copy_from_user(msg + 1, src, alen))
		goto out_err;

	for (seg = msg->next; seg != NULL; seg = seg->next) {
		len -= alen;
		src = (char __user *)src + alen;
		alen = min(len, DATALEN_SEG);
		if (copy_from_user(seg + 1, src, alen))
			goto out_err;
	}

	err = security_msg_msg_alloc(msg);
	if (err)
		goto out_err;

	return msg;

out_err:
	free_msg(msg);
	return ERR_PTR(err);
}
```

æ¥æ”¶æ¶ˆæ¯
- æ˜¯å¦å°†æ¶ˆæ¯freeæ‰ï¼Œå–å†³äºä¸€ä¸ªflag `MSG_COPY`, å¦‚æœå­˜åœ¨è¿™ä¸ª flag å°±è¦ alloc ä¸€å—ç¼“å†²åŒº
- msgflag ä¸åŒ…æ‹¬ MSG_COPY å°±ä¼š free æ‰ msg, åŒ…å«å°±ä¼š free æ‰ alloc çš„ç¼“å†²åŒº
- è°ƒç”¨ find_msg å¯»æ‰¾å¯¹åº”çš„ msg

```c
static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t))
{
	Â·Â·Â· Â·Â·Â·
	if (msgflg & MSG_COPY) {
		if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))
			return -EINVAL;
		copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));
		if (IS_ERR(copy)) 				//æœç´¢è¦å‘é€çš„æ¶ˆæ¯ä¹‹å‰ï¼Œå‡†å¤‡ä¸€ä¸ªæ¶ˆæ¯å¤‡ä»½(ç”³è¯·å†…å­˜)ï¼Œç”¨æ¥å­˜æ”¾æ¶ˆæ¯
			return PTR_ERR(copy);
	}
	Â·Â·Â· Â·Â·Â·
	for (;;) {
		Â·Â·Â· Â·Â·Â·
		msg = find_msg(msq, &msgtyp, mode);
		if (!IS_ERR(msg)) {
			Â·Â·Â· Â·Â·Â·
			if (msgflg & MSG_COPY) {
				msg = copy_msg(msg, copy); //æ‰¾åˆ°ä¹‹åæ‹·è´åˆ°æ¶ˆæ¯å¤‡ä»½ä¸­
				goto out_unlock0;
			}
			Â·Â·Â· Â·Â·Â·
		}        
        Â·Â·Â· Â·Â·Â·
	}
  //  Â·Â·Â· Â·Â·Â·
	bufsz = msg_handler(buf, msg, bufsz);
	free_msg(msg); //é‡Šæ”¾æ¶ˆæ¯å¤‡ä»½

	return bufsz;
}
```

é€šè¿‡find_msg å¯»æ‰¾åˆ°å¯¹åº”çš„ message
- msg_type åœ¨ä½¿ç”¨ MSG_COPY æ—¶, mode=SEARCH_NUMBER å°±æ˜¯**éå†æ¶ˆæ¯é˜Ÿåˆ—ï¼ŒæŒ‰ç…§é¡ºåºè¿›è¡Œæ‰¾æ¶ˆæ¯**

```cpp
static inline int convert_mode(long *msgtyp, int msgflg)
{
	if (msgflg & MSG_COPY)
		return SEARCH_NUMBER;
	// ...
}

static struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)
{
	struct msg_msg *msg, *found = NULL;
	long count = 0;

	list_for_each_entry(msg, &msq->q_messages, m_list) {
		if (testmsg(msg, *msgtyp, mode) &&
		    !security_msg_queue_msgrcv(&msq->q_perm, msg, current,
					       *msgtyp, mode)) {
			if (mode == SEARCH_LESSEQUAL && msg->m_type != 1) {
				*msgtyp = msg->m_type - 1;
				found = msg;
			} else if (mode == SEARCH_NUMBER) {
				if (*msgtyp == count)
					return msg;
			} else
				return msg;
			count++;
		}
	}

	return found ?: ERR_PTR(-EAGAIN);
}
```

## ç¼“è§£æœºåˆ¶

ç¦ç”¨ msg_msg ç»“æ„ä½“, å®ç°èµ·æ¥å…·ä½“ä¸ºç¦ç”¨ç›¸å…³çš„ syscall , è®©ç”¨æˆ·ä¸èƒ½è°ƒç”¨ç›¸å…³å‡½æ•°ã€‚
- Linux ptrace + epbf æŠ€æœ¯ä¿®æ”¹æ‰å¯¹åº”çš„syscall
- Docker å®šä¹‰ seccomp æ²™ç®±

## å‚è€ƒ

[corCTF 2021: Wall Of Perdition](https://syst3mfailure.io/wall-of-perdition/)
[corCTF 2022: CoRJail](https://syst3mfailure.io/corjail/)